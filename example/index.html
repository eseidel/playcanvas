<!DOCTYPE html>

<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="scaffolded-by" content="https://github.com/dart-lang/sdk">
  <title>playcanvas</title>
  <link rel="stylesheet" href="styles.css">
  <script src='https://code.playcanvas.com/playcanvas-stable.min.js'></script>
  <script defer src="main.dart.js"></script>
  <script>
    console.log(pc.Application);
  </script>
</head>

<body>
  <canvas id="canvas" height="450" width="600"></canvas>
  <script>
    // var canvas = document.getElementById('canvas');
    // const app = new pc.Application(canvas, {
    //   mouse: new pc.Mouse(document.body),
    //   touch: new pc.TouchDevice(document.body),
    //   elementInput: new pc.ElementInput(canvas),
    // });

    // app.start();

    // // Create an Entity with a camera component
    // const camera = new pc.Entity();
    // camera.addComponent("camera", {
    //   clearColor: new pc.Color(30 / 255, 30 / 255, 30 / 255),
    // });

    // camera.rotateLocal(-30, 0, 0);
    // camera.translateLocal(0, 0, 7);
    // app.root.addChild(camera);

    // // Create an Entity for the ground
    // const material = new pc.StandardMaterial();
    // material.diffuse = pc.Color.RED;
    // material.update();

    // const ground = new pc.Entity();
    // ground.addComponent("render", {
    //   type: "box",
    //   material: material,
    // });

    // ground.setLocalScale(50, 1, 50);
    // ground.setLocalPosition(0, -0.5, 0);
    // app.root.addChild(ground);

    // // Create an entity with a light component
    // const light = new pc.Entity();
    // light.addComponent("light", {
    //   type: "directional",
    //   color: new pc.Color(1, 1, 1),
    //   castShadows: true,
    //   intensity: 1,
    //   shadowBias: 0.2,
    //   shadowDistance: 16,
    //   normalOffsetBias: 0.05,
    //   shadowResolution: 2048,
    // });

    // light.setLocalEulerAngles(45, 30, 0);
    // app.root.addChild(light);

    // // Create a 2D screen
    // const screen = new pc.Entity();
    // screen.setLocalScale(0.01, 0.01, 0.01);
    // screen.addComponent("screen", {
    //   referenceResolution: new pc.Vec2(1280, 720),
    //   screenSpace: true,
    // });

    // app.root.addChild(screen);

    // /**
    //  * Converts a coordinate in world space into a screen's space.
    //  *
    //  * @param {pc.Vec3} worldPosition - the Vec3 representing the world-space coordinate.
    //  * @param {pc.CameraComponent} camera - the Camera.
    //  * @param {pc.ScreenComponent} screen - the Screen
    //  * @returns {pc.Vec3} a Vec3 of the input worldPosition relative to the camera and screen. The Z coordinate represents the depth,
    //  * and negative numbers signal that the worldPosition is behind the camera.
    //  */
    // function worldToScreenSpace(worldPosition, camera, screen) {
    //   const screenPos = camera.worldToScreen(worldPosition);

    //   // take pixel ratio into account
    //   const pixelRatio = app.graphicsDevice.maxPixelRatio;
    //   screenPos.x *= pixelRatio;
    //   screenPos.y *= pixelRatio;

    //   // account for screen scaling
    //   const scale = screen.scale;

    //   // invert the y position
    //   screenPos.y = screen.resolution.y - screenPos.y;

    //   // put that into a Vec3
    //   return new pc.Vec3(
    //     screenPos.x / scale,
    //     screenPos.y / scale,
    //     screenPos.z / scale
    //   );
    // }

    // function createPlayer(id, startingAngle, speed, radius) {
    //   // Create a capsule entity to represent a player in the 3d world
    //   const entity = new pc.Entity();
    //   entity.setLocalScale(new pc.Vec3(0.5, 0.5, 0.5));
    //   entity.addComponent("render", {
    //     type: "capsule",
    //   });

    //   app.root.addChild(entity);

    //   const angle = startingAngle;
    //   const height = 0.5;
    //   entity.setLocalPosition(
    //     radius * Math.sin(angle * pc.math.DEG_TO_RAD),
    //     height,
    //     radius * Math.cos(angle * pc.math.DEG_TO_RAD)
    //   );
    //   entity.setLocalEulerAngles(0, angle + 90, 0);
    // }

    // createPlayer(1, 135, 30, 1.5);
    // createPlayer(2, 65, -18, 1);
    // createPlayer(3, 0, 15, 2.5);
  </script>
</body>

</html>